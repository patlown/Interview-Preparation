 <canvas class="progressiveMedia-canvas js-progressiveMedia-canvas"></canvas><img class="progressiveMedia-image js-progressiveMedia-image" data-src="https://cdn-images-1.medium.com/max/960/1*gXSD-eGHKuUt-EwykgWv9Q.jpeg"><noscript class="js-progressiveMedia-inner"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-1.medium.com/max/960/1*gXSD-eGHKuUt-EwykgWv9Q.jpeg"></noscript></div></div><figcaption class="imageCaption">Just a cool matrix image.</figcaption></figure><p name="efd0" id="efd0" class="graf graf--p graf-after--figure">If you&#39;ve been in the software world for a while you&#39;ve probably faced some problem where you needed to do some processing over subsets of an array, right? No?! Well, let me bring you a simple one then.</p><p name="6107" id="6107" class="graf graf--p graf-after--p">Let&#39;s say I&#39;m riding the Bitcoin wave and I decided to track my gross gains on the last year:</p><pre name="0194" id="0194" class="graf graf--pre graf-after--p">gains = [102, 55, 320, 250, 215, 142, 54, 32, 121, 224, 458, 276]</pre><p name="5aa8" id="5aa8" class="graf graf--p graf-after--pre">(hey, they’re just sample data :-)</p><p name="9337" id="9337" class="graf graf--p graf-after--p">I started then to think in a couple of queries to apply over the <code class="markup--code markup--p-code">gains</code> array so that I could check how much I earned by period.</p><p name="910a" id="910a" class="graf graf--p graf-after--p">What I would like to know is the total amount I earned for:</p><ul class="postList"><li name="19a9" id="19a9" class="graf graf--li graf-after--p">The whole year;</li><li name="2a4e" id="2a4e" class="graf graf--li graf-after--li">The first couple of months;</li><li name="75ab" id="75ab" class="graf graf--li graf-after--li">The last quarter of the year.</li></ul><p name="65a6" id="65a6" class="graf graf--p graf-after--li">Those queries could easily be translated to a Ruby code like this:</p><pre name="c05b" id="c05b" class="graf graf--pre graf-after--p">queries = [<br>  0..11, # whole year<br>  0..1,  # first 2 months<br>  9..11  # last quarter<br>]</pre><p name="35e9" id="35e9" class="graf graf--p graf-after--pre">It seems quite simple to take those indexes and sum the values in their range. And yes, it is. But be careful my young Padawan or you may fall in a performance trap.</p><p name="b020" id="b020" class="graf graf--p graf-after--p graf--trailing">Ok, so how to implement that though?</p></div></div></section><section name="b1c8" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="d605" id="d605" class="graf graf--h3 graf--leading">First Approach (worse): O(N * M)</h3><p name="f1bf" id="f1bf" class="graf graf--p graf-after--h3">Naturally, the first solution that comes up to our mind is to take each slice of <code class="markup--code markup--p-code">gains</code> , based on the given query (range), and then iterate over its elements to sum all values.</p><pre name="dce6" id="dce6" class="graf graf--pre graf-after--p">gains   = [102, 55, 320, 250, 215, 142, 54, 32, 121, 224, 458, 276]<br>queries = [0..11, 0..1, 9..11]</pre><pre name="46e2" id="46e2" class="graf graf--pre graf-after--pre">queries.map do |query|<br>  gains[query].reduce(:+)<br>end</pre><pre name="bccd" id="bccd" class="graf graf--pre graf-after--pre"># Result: [2249, 157, 958]</pre><p name="3ef8" id="3ef8" class="graf graf--p graf-after--pre">Done! Problem solved with a neat and small code. Next.</p><p name="4e9d" id="4e9d" class="graf graf--p graf-after--p">Hold on, not yet: this solution is in fact effective but it&#39;s not that much efficient.</p><p name="42b7" id="42b7" class="graf graf--p graf-after--p">For a small input of data (i.e. our current <code class="markup--code markup--p-code">gains</code> and <code class="markup--code markup--p-code">queries</code> arrays) this approach will definitely work fast, but let&#39;s assume a future where I had tracked those gains over the past 50 years (50 * 12 = 600) and for that period a I ended up producing a collection of 10.000 different combinations of queries. Well, now we start having some respectable data to play around.</p><p name="6a70" id="6a70" class="graf graf--p graf-after--p">If I wanted to process all the queries at once, then the same code that once was apparently responding very well now starts to get some substantial performance losses. The problem in a nutshell: its <a href="https://en.wikipedia.org/wiki/Time_complexity" data-href="https://en.wikipedia.org/wiki/Time_complexity" class="markup--anchor markup--p-anchor" rel="noopener nofollow" target="_blank">time complexity</a>.</p><p name="74f4" id="74f4" class="graf graf--p graf-after--p">Just in case you&#39;re not used to this &quot;complexity&quot; topic:</p><p name="f886" id="f886" class="graf graf--p graf-after--p">When we talk about time complexity we&#39;re actually talking about how well our code scales in face of large inputs. Usually we represent this potential of scalability with <a href="https://en.wikipedia.org/wiki/Big_O_notation" data-href="https://en.wikipedia.org/wiki/Big_O_notation" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">Big-O notation</a> and for notation purposes it always considers the algorithm’s worst case scenario when defining its complexity. You can also understand the complexity as the maximum amount of constant-time<strong class="markup--strong markup--p-strong"> </strong>primary operations (<strong class="markup--strong markup--p-strong">O(1)</strong>) that a program may execute. Such operations are: addition, subtraction, comparison, assignment etc.</p><p name="9fda" id="9fda" class="graf graf--p graf-after--p">So, having the size of <code class="markup--code markup--p-code">gains</code> as <strong class="markup--strong markup--p-strong">N </strong>and <code class="markup--code markup--p-code">queries</code> as <strong class="markup--strong markup--p-strong">M, </strong>the first approach will take each query (<strong class="markup--strong markup--p-strong">O(M)</strong>) and traverse the respective slice on <code class="markup--code markup--p-code">gains</code> (<strong class="markup--strong markup--p-strong">O(N)</strong>) to sum its values. The algorithm&#39;s performance is then represented by the notation: <strong class="markup--strong markup--p-strong">O(N * M). </strong>When thinking in the worst case scenario, it would have had to sum all the 600 values (biggest possible slice) 10k times, which would lead to 6 million primary operations being executed on the CPU while running the algorithm.</p><p name="fe37" id="fe37" class="graf graf--p graf-after--p graf--trailing">What if we could reduce the worst case to only 10.6k operations?</p></div></div></section><section name="ef17" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="8f85" id="8f85" class="graf graf--h3 graf--leading">Second Approach (better): O(N + M)</h3><p name="81ae" id="81ae" class="graf graf--p graf-after--h3">First, let me quickly introduce the <a href="https://en.wikipedia.org/wiki/Prefix_sum" data-href="https://en.wikipedia.org/wiki/Prefix_sum" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">prefix sums</a> technique: it basically describes a way to pre-compute the cumulative sum for each value in a sequence, so they can be used later for a faster calculation of the total between the given indexes.</p><p name="4e29" id="4e29" class="graf graf--p graf-after--p">The reason for using this technique: the sum operation on the slices that once was responding linearly (traverse elements) now happens in constant time, since it’s only a matter of subtracting their prefix sums.</p><p name="6750" id="6750" class="graf graf--p graf-after--p">So here&#39;s how we can improve the previous algorithm:</p><pre name="3d09" id="3d09" class="graf graf--pre graf-after--p">gains   = [102, 55, 320, 250, 215, 142, 54, 32, 121, 224, 458, 276]<br>queries = [0..11, 0..1, 9..11]<br>sums    = [0]</pre><pre name="3e94" id="3e94" class="graf graf--pre graf-after--pre"># 1. Prefix sum calculation:<br>(1..gains.length).each do |i|<br>  sums[i] = sums[i - 1] + gains[i - 1]<br>end</pre><pre name="8f23" id="8f23" class="graf graf--pre graf-after--pre"># 2. Query resolution:<br>queries.map do |query|<br>  sums[query.end + 1] - sums[query.begin]<br>end</pre><pre name="d341" id="d341" class="graf graf--pre graf-after--pre"># Result: [2249, 157, 958]</pre><p name="faf9" id="faf9" class="graf graf--p graf-after--pre">Initially what it does is an O(N) operation to calcule all the cumulative sums based on the <code class="markup--code markup--p-code">gains</code> array. For instance, with <code class="markup--code markup--p-code">gains = [1, 2, 3]</code> it would compute <code class="markup--code markup--p-code">sums = [0, 1, 3, 6]</code>.</p><p name="fdc9" id="fdc9" class="graf graf--p graf-after--p">The second part just takes each query, O(M), and subtracts the pre-computed sums found in <code class="markup--code markup--p-code">sums</code> array. The correctness is ensured since the difference between their prefix sums is equivalent to the sum of all values present in their range.</p><p name="94a3" id="94a3" class="graf graf--p graf-after--p graf--trailing">As we&#39;ve got two different linear operations happening here, the resulting time complexity is their sum: O(N) + O(M) = <strong class="markup--strong markup--p-strong">O(N + M)</strong>. Thus, for a large input of data like 600 gains and 10k queries, in the worst case it would execute only 10.6k operations on the CPU. That is, for this input, we have about 99% less operations happening in comparison to the previous algorithm.</p></div></div></section><section name="8369" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="342e" id="342e" class="graf graf--h3 graf--leading">Conclusion</h3><p name="2f78" id="2f78" class="graf graf--p graf-after--h3">Some solutions may appear to be very obvious at a first glance, but it&#39;s worth trying to reflect a bit more over the problem in order to figure out if there&#39;s any hidden pay off (aka trap) when going with the most obvious one.</p><p name="88a9" id="88a9" class="graf graf--p graf-after--p graf--trailing">Another thing to keep in mind is that, in face of performance issues, people usually blame something in their current tech stack (language, framework, libs etc), without realizing that the actual problem may be related to how the solution was designed. So having a better understanding not only of algorithm techniques, but architecture and design patterns, for instance, will certainly bring more performant solutions to the software you build.